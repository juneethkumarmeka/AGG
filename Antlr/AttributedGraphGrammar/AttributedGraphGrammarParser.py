# Generated from .\AttributedGraphGrammar.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\33")
        buf.write("\u018c\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\3\2\3\2\3\2\3\2\3\2\3")
        buf.write("\2\3\2\3\3\3\3\3\4\3\4\3\5\3\5\3\6\3\6\3\6\3\6\5\6\u0092")
        buf.write("\n\6\3\6\3\6\3\6\3\6\5\6\u0098\n\6\5\6\u009a\n\6\3\7\6")
        buf.write("\7\u009d\n\7\r\7\16\7\u009e\3\b\3\b\3\b\5\b\u00a4\n\b")
        buf.write("\3\b\3\b\3\b\3\b\3\t\6\t\u00ab\n\t\r\t\16\t\u00ac\3\n")
        buf.write("\3\n\3\n\3\n\3\n\7\n\u00b4\n\n\f\n\16\n\u00b7\13\n\3\n")
        buf.write("\3\n\3\n\3\n\3\n\3\n\3\n\5\n\u00c0\n\n\3\13\3\13\3\f\3")
        buf.write("\f\3\r\3\r\3\16\3\16\3\16\3\16\3\16\3\16\3\17\3\17\3\20")
        buf.write("\3\20\3\21\3\21\3\22\3\22\3\23\3\23\3\24\3\24\3\24\3\24")
        buf.write("\3\24\7\24\u00dd\n\24\f\24\16\24\u00e0\13\24\3\24\3\24")
        buf.write("\3\24\7\24\u00e5\n\24\f\24\16\24\u00e8\13\24\3\24\3\24")
        buf.write("\3\25\3\25\3\26\3\26\3\27\3\27\3\30\3\30\3\30\3\30\3\30")
        buf.write("\3\30\3\31\3\31\3\32\3\32\3\33\3\33\3\33\5\33\u00ff\n")
        buf.write("\33\3\33\3\33\3\33\3\33\3\34\3\34\3\35\3\35\3\36\3\36")
        buf.write("\3\37\3\37\3\37\5\37\u010e\n\37\3\37\3\37\3\37\3\37\3")
        buf.write(" \3 \3!\3!\3\"\3\"\3#\3#\3#\3#\3#\3#\3#\3$\3$\3%\3%\3")
        buf.write("&\3&\3\'\7\'\u0128\n\'\f\'\16\'\u012b\13\'\3(\3(\5(\u012f")
        buf.write("\n(\3)\3)\3)\3)\3)\3)\3)\3)\7)\u0139\n)\f)\16)\u013c\13")
        buf.write(")\3)\3)\3*\3*\3*\3*\3*\3+\3+\3,\3,\3-\3-\3.\3.\3.\3.\3")
        buf.write("/\3/\3\60\3\60\3\61\3\61\3\62\3\62\3\63\6\63\u0158\n\63")
        buf.write("\r\63\16\63\u0159\3\64\3\64\3\64\3\64\3\64\3\64\3\64\3")
        buf.write("\65\3\65\3\66\3\66\3\67\7\67\u0168\n\67\f\67\16\67\u016b")
        buf.write("\13\67\38\38\39\39\39\39\39\79\u0174\n9\f9\169\u0177\13")
        buf.write("9\39\39\3:\3:\3;\3;\3<\3<\3<\3<\3<\3=\3=\3>\3>\3?\3?\3")
        buf.write("@\3@\3@\6\u00b5\u00de\u00e6\u013a\2A\2\4\6\b\n\f\16\20")
        buf.write("\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJL")
        buf.write("NPRTVXZ\\^`bdfhjlnprtvxz|~\2\3\3\2\27\30\2\u015e\2\u0080")
        buf.write("\3\2\2\2\4\u0087\3\2\2\2\6\u0089\3\2\2\2\b\u008b\3\2\2")
        buf.write("\2\n\u0099\3\2\2\2\f\u009c\3\2\2\2\16\u00a0\3\2\2\2\20")
        buf.write("\u00aa\3\2\2\2\22\u00bf\3\2\2\2\24\u00c1\3\2\2\2\26\u00c3")
        buf.write("\3\2\2\2\30\u00c5\3\2\2\2\32\u00c7\3\2\2\2\34\u00cd\3")
        buf.write("\2\2\2\36\u00cf\3\2\2\2 \u00d1\3\2\2\2\"\u00d3\3\2\2\2")
        buf.write("$\u00d5\3\2\2\2&\u00d7\3\2\2\2(\u00eb\3\2\2\2*\u00ed\3")
        buf.write("\2\2\2,\u00ef\3\2\2\2.\u00f1\3\2\2\2\60\u00f7\3\2\2\2")
        buf.write("\62\u00f9\3\2\2\2\64\u00fb\3\2\2\2\66\u0104\3\2\2\28\u0106")
        buf.write("\3\2\2\2:\u0108\3\2\2\2<\u010a\3\2\2\2>\u0113\3\2\2\2")
        buf.write("@\u0115\3\2\2\2B\u0117\3\2\2\2D\u0119\3\2\2\2F\u0120\3")
        buf.write("\2\2\2H\u0122\3\2\2\2J\u0124\3\2\2\2L\u0129\3\2\2\2N\u012e")
        buf.write("\3\2\2\2P\u0130\3\2\2\2R\u013f\3\2\2\2T\u0144\3\2\2\2")
        buf.write("V\u0146\3\2\2\2X\u0148\3\2\2\2Z\u014a\3\2\2\2\\\u014e")
        buf.write("\3\2\2\2^\u0150\3\2\2\2`\u0152\3\2\2\2b\u0154\3\2\2\2")
        buf.write("d\u0157\3\2\2\2f\u015b\3\2\2\2h\u0162\3\2\2\2j\u0164\3")
        buf.write("\2\2\2l\u0169\3\2\2\2n\u016c\3\2\2\2p\u016e\3\2\2\2r\u017a")
        buf.write("\3\2\2\2t\u017c\3\2\2\2v\u017e\3\2\2\2x\u0183\3\2\2\2")
        buf.write("z\u0185\3\2\2\2|\u0187\3\2\2\2~\u0189\3\2\2\2\u0080\u0081")
        buf.write("\7\3\2\2\u0081\u0082\7\4\2\2\u0082\u0083\5\b\5\2\u0083")
        buf.write("\u0084\5\4\3\2\u0084\u0085\5\n\6\2\u0085\u0086\5\6\4\2")
        buf.write("\u0086\3\3\2\2\2\u0087\u0088\7\31\2\2\u0088\5\3\2\2\2")
        buf.write("\u0089\u008a\7\32\2\2\u008a\7\3\2\2\2\u008b\u008c\7\25")
        buf.write("\2\2\u008c\t\3\2\2\2\u008d\u008e\5\f\7\2\u008e\u008f\5")
        buf.write("\16\b\2\u008f\u0091\5\20\t\2\u0090\u0092\5d\63\2\u0091")
        buf.write("\u0090\3\2\2\2\u0091\u0092\3\2\2\2\u0092\u009a\3\2\2\2")
        buf.write("\u0093\u0094\5\f\7\2\u0094\u0095\5\20\t\2\u0095\u0097")
        buf.write("\5\16\b\2\u0096\u0098\5d\63\2\u0097\u0096\3\2\2\2\u0097")
        buf.write("\u0098\3\2\2\2\u0098\u009a\3\2\2\2\u0099\u008d\3\2\2\2")
        buf.write("\u0099\u0093\3\2\2\2\u009a\13\3\2\2\2\u009b\u009d\5\22")
        buf.write("\n\2\u009c\u009b\3\2\2\2\u009d\u009e\3\2\2\2\u009e\u009c")
        buf.write("\3\2\2\2\u009e\u009f\3\2\2\2\u009f\r\3\2\2\2\u00a0\u00a3")
        buf.write("\7\5\2\2\u00a1\u00a2\7\4\2\2\u00a2\u00a4\5 \21\2\u00a3")
        buf.write("\u00a1\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a5\3\2\2\2")
        buf.write("\u00a5\u00a6\5\"\22\2\u00a6\u00a7\5L\'\2\u00a7\u00a8\5")
        buf.write("$\23\2\u00a8\17\3\2\2\2\u00a9\u00ab\5&\24\2\u00aa\u00a9")
        buf.write("\3\2\2\2\u00ab\u00ac\3\2\2\2\u00ac\u00aa\3\2\2\2\u00ac")
        buf.write("\u00ad\3\2\2\2\u00ad\21\3\2\2\2\u00ae\u00af\7\6\2\2\u00af")
        buf.write("\u00b0\7\4\2\2\u00b0\u00b1\5\24\13\2\u00b1\u00b5\5\26")
        buf.write("\f\2\u00b2\u00b4\5\32\16\2\u00b3\u00b2\3\2\2\2\u00b4\u00b7")
        buf.write("\3\2\2\2\u00b5\u00b6\3\2\2\2\u00b5\u00b3\3\2\2\2\u00b6")
        buf.write("\u00b8\3\2\2\2\u00b7\u00b5\3\2\2\2\u00b8\u00b9\5\30\r")
        buf.write("\2\u00b9\u00c0\3\2\2\2\u00ba\u00bb\7\6\2\2\u00bb\u00bc")
        buf.write("\7\4\2\2\u00bc\u00bd\5\24\13\2\u00bd\u00be\5~@\2\u00be")
        buf.write("\u00c0\3\2\2\2\u00bf\u00ae\3\2\2\2\u00bf\u00ba\3\2\2\2")
        buf.write("\u00c0\23\3\2\2\2\u00c1\u00c2\7\25\2\2\u00c2\25\3\2\2")
        buf.write("\2\u00c3\u00c4\7\31\2\2\u00c4\27\3\2\2\2\u00c5\u00c6\7")
        buf.write("\32\2\2\u00c6\31\3\2\2\2\u00c7\u00c8\7\7\2\2\u00c8\u00c9")
        buf.write("\7\4\2\2\u00c9\u00ca\5\34\17\2\u00ca\u00cb\5\36\20\2\u00cb")
        buf.write("\u00cc\5~@\2\u00cc\33\3\2\2\2\u00cd\u00ce\7\30\2\2\u00ce")
        buf.write("\35\3\2\2\2\u00cf\u00d0\7\30\2\2\u00d0\37\3\2\2\2\u00d1")
        buf.write("\u00d2\7\25\2\2\u00d2!\3\2\2\2\u00d3\u00d4\7\31\2\2\u00d4")
        buf.write("#\3\2\2\2\u00d5\u00d6\7\32\2\2\u00d6%\3\2\2\2\u00d7\u00d8")
        buf.write("\7\b\2\2\u00d8\u00d9\7\4\2\2\u00d9\u00da\5(\25\2\u00da")
        buf.write("\u00de\5*\26\2\u00db\u00dd\5.\30\2\u00dc\u00db\3\2\2\2")
        buf.write("\u00dd\u00e0\3\2\2\2\u00de\u00df\3\2\2\2\u00de\u00dc\3")
        buf.write("\2\2\2\u00df\u00e1\3\2\2\2\u00e0\u00de\3\2\2\2\u00e1\u00e2")
        buf.write("\5\64\33\2\u00e2\u00e6\5<\37\2\u00e3\u00e5\5D#\2\u00e4")
        buf.write("\u00e3\3\2\2\2\u00e5\u00e8\3\2\2\2\u00e6\u00e7\3\2\2\2")
        buf.write("\u00e6\u00e4\3\2\2\2\u00e7\u00e9\3\2\2\2\u00e8\u00e6\3")
        buf.write("\2\2\2\u00e9\u00ea\5,\27\2\u00ea\'\3\2\2\2\u00eb\u00ec")
        buf.write("\7\30\2\2\u00ec)\3\2\2\2\u00ed\u00ee\7\31\2\2\u00ee+\3")
        buf.write("\2\2\2\u00ef\u00f0\7\32\2\2\u00f0-\3\2\2\2\u00f1\u00f2")
        buf.write("\7\t\2\2\u00f2\u00f3\7\4\2\2\u00f3\u00f4\5\60\31\2\u00f4")
        buf.write("\u00f5\5\62\32\2\u00f5\u00f6\5~@\2\u00f6/\3\2\2\2\u00f7")
        buf.write("\u00f8\7\30\2\2\u00f8\61\3\2\2\2\u00f9\u00fa\7\30\2\2")
        buf.write("\u00fa\63\3\2\2\2\u00fb\u00fe\7\n\2\2\u00fc\u00fd\7\4")
        buf.write("\2\2\u00fd\u00ff\5\66\34\2\u00fe\u00fc\3\2\2\2\u00fe\u00ff")
        buf.write("\3\2\2\2\u00ff\u0100\3\2\2\2\u0100\u0101\58\35\2\u0101")
        buf.write("\u0102\5L\'\2\u0102\u0103\5:\36\2\u0103\65\3\2\2\2\u0104")
        buf.write("\u0105\7\30\2\2\u0105\67\3\2\2\2\u0106\u0107\7\31\2\2")
        buf.write("\u01079\3\2\2\2\u0108\u0109\7\32\2\2\u0109;\3\2\2\2\u010a")
        buf.write("\u010d\7\13\2\2\u010b\u010c\7\4\2\2\u010c\u010e\5> \2")
        buf.write("\u010d\u010b\3\2\2\2\u010d\u010e\3\2\2\2\u010e\u010f\3")
        buf.write("\2\2\2\u010f\u0110\5@!\2\u0110\u0111\5L\'\2\u0111\u0112")
        buf.write("\5B\"\2\u0112=\3\2\2\2\u0113\u0114\7\30\2\2\u0114?\3\2")
        buf.write("\2\2\u0115\u0116\7\31\2\2\u0116A\3\2\2\2\u0117\u0118\7")
        buf.write("\32\2\2\u0118C\3\2\2\2\u0119\u011a\7\f\2\2\u011a\u011b")
        buf.write("\7\4\2\2\u011b\u011c\5F$\2\u011c\u011d\5H%\2\u011d\u011e")
        buf.write("\5L\'\2\u011e\u011f\5J&\2\u011fE\3\2\2\2\u0120\u0121\7")
        buf.write("\30\2\2\u0121G\3\2\2\2\u0122\u0123\7\31\2\2\u0123I\3\2")
        buf.write("\2\2\u0124\u0125\7\32\2\2\u0125K\3\2\2\2\u0126\u0128\5")
        buf.write("N(\2\u0127\u0126\3\2\2\2\u0128\u012b\3\2\2\2\u0129\u0127")
        buf.write("\3\2\2\2\u0129\u012a\3\2\2\2\u012aM\3\2\2\2\u012b\u0129")
        buf.write("\3\2\2\2\u012c\u012f\5P)\2\u012d\u012f\5R*\2\u012e\u012c")
        buf.write("\3\2\2\2\u012e\u012d\3\2\2\2\u012fO\3\2\2\2\u0130\u0131")
        buf.write("\7\r\2\2\u0131\u0132\5T+\2\u0132\u0133\7\16\2\2\u0133")
        buf.write("\u0134\5V,\2\u0134\u0135\7\17\2\2\u0135\u013a\5X-\2\u0136")
        buf.write("\u0137\7\16\2\2\u0137\u0139\5Z.\2\u0138\u0136\3\2\2\2")
        buf.write("\u0139\u013c\3\2\2\2\u013a\u013b\3\2\2\2\u013a\u0138\3")
        buf.write("\2\2\2\u013b\u013d\3\2\2\2\u013c\u013a\3\2\2\2\u013d\u013e")
        buf.write("\5~@\2\u013eQ\3\2\2\2\u013f\u0140\5`\61\2\u0140\u0141")
        buf.write("\7\20\2\2\u0141\u0142\5b\62\2\u0142\u0143\5~@\2\u0143")
        buf.write("S\3\2\2\2\u0144\u0145\7\30\2\2\u0145U\3\2\2\2\u0146\u0147")
        buf.write("\7\6\2\2\u0147W\3\2\2\2\u0148\u0149\7\30\2\2\u0149Y\3")
        buf.write("\2\2\2\u014a\u014b\5\\/\2\u014b\u014c\7\17\2\2\u014c\u014d")
        buf.write("\5^\60\2\u014d[\3\2\2\2\u014e\u014f\7\25\2\2\u014f]\3")
        buf.write("\2\2\2\u0150\u0151\t\2\2\2\u0151_\3\2\2\2\u0152\u0153")
        buf.write("\7\30\2\2\u0153a\3\2\2\2\u0154\u0155\7\30\2\2\u0155c\3")
        buf.write("\2\2\2\u0156\u0158\5f\64\2\u0157\u0156\3\2\2\2\u0158\u0159")
        buf.write("\3\2\2\2\u0159\u0157\3\2\2\2\u0159\u015a\3\2\2\2\u015a")
        buf.write("e\3\2\2\2\u015b\u015c\7\21\2\2\u015c\u015d\7\4\2\2\u015d")
        buf.write("\u015e\5h\65\2\u015e\u015f\5j\66\2\u015f\u0160\5l\67\2")
        buf.write("\u0160\u0161\5n8\2\u0161g\3\2\2\2\u0162\u0163\7\30\2\2")
        buf.write("\u0163i\3\2\2\2\u0164\u0165\7\31\2\2\u0165k\3\2\2\2\u0166")
        buf.write("\u0168\5p9\2\u0167\u0166\3\2\2\2\u0168\u016b\3\2\2\2\u0169")
        buf.write("\u0167\3\2\2\2\u0169\u016a\3\2\2\2\u016am\3\2\2\2\u016b")
        buf.write("\u0169\3\2\2\2\u016c\u016d\7\32\2\2\u016do\3\2\2\2\u016e")
        buf.write("\u016f\7\22\2\2\u016f\u0170\7\4\2\2\u0170\u0171\5r:\2")
        buf.write("\u0171\u0175\5t;\2\u0172\u0174\5v<\2\u0173\u0172\3\2\2")
        buf.write("\2\u0174\u0177\3\2\2\2\u0175\u0173\3\2\2\2\u0175\u0176")
        buf.write("\3\2\2\2\u0176\u0178\3\2\2\2\u0177\u0175\3\2\2\2\u0178")
        buf.write("\u0179\5|?\2\u0179q\3\2\2\2\u017a\u017b\7\27\2\2\u017b")
        buf.write("s\3\2\2\2\u017c\u017d\7\31\2\2\u017du\3\2\2\2\u017e\u017f")
        buf.write("\5x=\2\u017f\u0180\7\4\2\2\u0180\u0181\5z>\2\u0181\u0182")
        buf.write("\5~@\2\u0182w\3\2\2\2\u0183\u0184\7\30\2\2\u0184y\3\2")
        buf.write("\2\2\u0185\u0186\7\27\2\2\u0186{\3\2\2\2\u0187\u0188\7")
        buf.write("\32\2\2\u0188}\3\2\2\2\u0189\u018a\7\23\2\2\u018a\177")
        buf.write("\3\2\2\2\24\u0091\u0097\u0099\u009e\u00a3\u00ac\u00b5")
        buf.write("\u00bf\u00de\u00e6\u00fe\u010d\u0129\u012e\u013a\u0159")
        buf.write("\u0169\u0175")
        return buf.getvalue()


class AttributedGraphGrammarParser ( Parser ):

    grammarFileName = "AttributedGraphGrammar.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'AttributedGrammar'", "':'", "'HostGraph'", 
                     "'NodeType'", "'Attribute'", "'Rule'", "'Var'", "'LHS'", 
                     "'RHS'", "'NAC'", "'AddNode'", "','", "'='", "'->'", 
                     "'RuleSequence'", "'SubSequence'", "';'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'{'", "'}'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "COMMENT", "ID", "EXPR", 
                      "INT", "STRING", "LEFTPARAN", "RIGHTPARAN", "WS" ]

    RULE_start = 0
    RULE_startgrammar = 1
    RULE_endgrammar = 2
    RULE_grammarname = 3
    RULE_grammarstructures = 4
    RULE_nodetypes = 5
    RULE_hostgraph = 6
    RULE_rules = 7
    RULE_nodetype = 8
    RULE_nodetypename = 9
    RULE_startnodetype = 10
    RULE_endnodetype = 11
    RULE_nodetypeattribute = 12
    RULE_nodetypeattributename = 13
    RULE_nodetypeattributetype = 14
    RULE_hostgraphname = 15
    RULE_starthostgraph = 16
    RULE_endhostgraph = 17
    RULE_rule_ = 18
    RULE_rulename = 19
    RULE_startrule = 20
    RULE_endrule = 21
    RULE_ruleparameter = 22
    RULE_ruleparametername = 23
    RULE_ruleparametertype = 24
    RULE_rulelhs = 25
    RULE_rulelhsname = 26
    RULE_startrulelhs = 27
    RULE_endrulelhs = 28
    RULE_rulerhs = 29
    RULE_rulerhsname = 30
    RULE_startrulerhs = 31
    RULE_endrulerhs = 32
    RULE_rulenac = 33
    RULE_rulenacname = 34
    RULE_startrulenac = 35
    RULE_endrulenac = 36
    RULE_graph = 37
    RULE_graphstructures = 38
    RULE_addnode = 39
    RULE_addedge = 40
    RULE_nodename = 41
    RULE_nodeType = 42
    RULE_nodeTypeValue = 43
    RULE_nodeattribute = 44
    RULE_nodeattributename = 45
    RULE_nodeattributevalue = 46
    RULE_edgesource = 47
    RULE_edgetarget = 48
    RULE_rulesequences = 49
    RULE_rulesequence = 50
    RULE_rulesequencename = 51
    RULE_startrulesequence = 52
    RULE_subsequences = 53
    RULE_endrulesequence = 54
    RULE_subsequence = 55
    RULE_subsequenceiternationcount = 56
    RULE_startsubsequence = 57
    RULE_rulesequnececount = 58
    RULE_rulesequencerulename = 59
    RULE_rulecount = 60
    RULE_endsubsequence = 61
    RULE_semicolon = 62

    ruleNames =  [ "start", "startgrammar", "endgrammar", "grammarname", 
                   "grammarstructures", "nodetypes", "hostgraph", "rules", 
                   "nodetype", "nodetypename", "startnodetype", "endnodetype", 
                   "nodetypeattribute", "nodetypeattributename", "nodetypeattributetype", 
                   "hostgraphname", "starthostgraph", "endhostgraph", "rule_", 
                   "rulename", "startrule", "endrule", "ruleparameter", 
                   "ruleparametername", "ruleparametertype", "rulelhs", 
                   "rulelhsname", "startrulelhs", "endrulelhs", "rulerhs", 
                   "rulerhsname", "startrulerhs", "endrulerhs", "rulenac", 
                   "rulenacname", "startrulenac", "endrulenac", "graph", 
                   "graphstructures", "addnode", "addedge", "nodename", 
                   "nodeType", "nodeTypeValue", "nodeattribute", "nodeattributename", 
                   "nodeattributevalue", "edgesource", "edgetarget", "rulesequences", 
                   "rulesequence", "rulesequencename", "startrulesequence", 
                   "subsequences", "endrulesequence", "subsequence", "subsequenceiternationcount", 
                   "startsubsequence", "rulesequnececount", "rulesequencerulename", 
                   "rulecount", "endsubsequence", "semicolon" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    COMMENT=18
    ID=19
    EXPR=20
    INT=21
    STRING=22
    LEFTPARAN=23
    RIGHTPARAN=24
    WS=25

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def grammarname(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.GrammarnameContext,0)


        def startgrammar(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.StartgrammarContext,0)


        def grammarstructures(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.GrammarstructuresContext,0)


        def endgrammar(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EndgrammarContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStart" ):
                return visitor.visitStart(self)
            else:
                return visitor.visitChildren(self)




    def start(self):

        localctx = AttributedGraphGrammarParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            self.match(AttributedGraphGrammarParser.T__0)
            self.state = 127
            self.match(AttributedGraphGrammarParser.T__1)
            self.state = 128
            self.grammarname()
            self.state = 129
            self.startgrammar()
            self.state = 130
            self.grammarstructures()
            self.state = 131
            self.endgrammar()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartgrammarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.LEFTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_startgrammar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartgrammar" ):
                listener.enterStartgrammar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartgrammar" ):
                listener.exitStartgrammar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartgrammar" ):
                return visitor.visitStartgrammar(self)
            else:
                return visitor.visitChildren(self)




    def startgrammar(self):

        localctx = AttributedGraphGrammarParser.StartgrammarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_startgrammar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.match(AttributedGraphGrammarParser.LEFTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndgrammarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.RIGHTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_endgrammar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndgrammar" ):
                listener.enterEndgrammar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndgrammar" ):
                listener.exitEndgrammar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndgrammar" ):
                return visitor.visitEndgrammar(self)
            else:
                return visitor.visitChildren(self)




    def endgrammar(self):

        localctx = AttributedGraphGrammarParser.EndgrammarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_endgrammar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.match(AttributedGraphGrammarParser.RIGHTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GrammarnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(AttributedGraphGrammarParser.ID, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_grammarname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrammarname" ):
                listener.enterGrammarname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrammarname" ):
                listener.exitGrammarname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrammarname" ):
                return visitor.visitGrammarname(self)
            else:
                return visitor.visitChildren(self)




    def grammarname(self):

        localctx = AttributedGraphGrammarParser.GrammarnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_grammarname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(AttributedGraphGrammarParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GrammarstructuresContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodetypes(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.NodetypesContext,0)


        def hostgraph(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.HostgraphContext,0)


        def rules(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulesContext,0)


        def rulesequences(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulesequencesContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_grammarstructures

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrammarstructures" ):
                listener.enterGrammarstructures(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrammarstructures" ):
                listener.exitGrammarstructures(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGrammarstructures" ):
                return visitor.visitGrammarstructures(self)
            else:
                return visitor.visitChildren(self)




    def grammarstructures(self):

        localctx = AttributedGraphGrammarParser.GrammarstructuresContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_grammarstructures)
        self._la = 0 # Token type
        try:
            self.state = 151
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 139
                self.nodetypes()
                self.state = 140
                self.hostgraph()
                self.state = 141
                self.rules()
                self.state = 143
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AttributedGraphGrammarParser.T__14:
                    self.state = 142
                    self.rulesequences()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 145
                self.nodetypes()
                self.state = 146
                self.rules()
                self.state = 147
                self.hostgraph()
                self.state = 149
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AttributedGraphGrammarParser.T__14:
                    self.state = 148
                    self.rulesequences()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodetypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodetype(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.NodetypeContext)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.NodetypeContext,i)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodetypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodetypes" ):
                listener.enterNodetypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodetypes" ):
                listener.exitNodetypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodetypes" ):
                return visitor.visitNodetypes(self)
            else:
                return visitor.visitChildren(self)




    def nodetypes(self):

        localctx = AttributedGraphGrammarParser.NodetypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_nodetypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 153
                self.nodetype()
                self.state = 156 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==AttributedGraphGrammarParser.T__3):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HostgraphContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def starthostgraph(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.StarthostgraphContext,0)


        def graph(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.GraphContext,0)


        def endhostgraph(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EndhostgraphContext,0)


        def hostgraphname(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.HostgraphnameContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_hostgraph

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHostgraph" ):
                listener.enterHostgraph(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHostgraph" ):
                listener.exitHostgraph(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHostgraph" ):
                return visitor.visitHostgraph(self)
            else:
                return visitor.visitChildren(self)




    def hostgraph(self):

        localctx = AttributedGraphGrammarParser.HostgraphContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_hostgraph)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(AttributedGraphGrammarParser.T__2)
            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AttributedGraphGrammarParser.T__1:
                self.state = 159
                self.match(AttributedGraphGrammarParser.T__1)
                self.state = 160
                self.hostgraphname()


            self.state = 163
            self.starthostgraph()
            self.state = 164
            self.graph()
            self.state = 165
            self.endhostgraph()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rule_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.Rule_Context)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.Rule_Context,i)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rules

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRules" ):
                listener.enterRules(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRules" ):
                listener.exitRules(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRules" ):
                return visitor.visitRules(self)
            else:
                return visitor.visitChildren(self)




    def rules(self):

        localctx = AttributedGraphGrammarParser.RulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_rules)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 167
                self.rule_()
                self.state = 170 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==AttributedGraphGrammarParser.T__5):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodetypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodetypename(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.NodetypenameContext,0)


        def startnodetype(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.StartnodetypeContext,0)


        def endnodetype(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EndnodetypeContext,0)


        def nodetypeattribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.NodetypeattributeContext)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.NodetypeattributeContext,i)


        def semicolon(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.SemicolonContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodetype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodetype" ):
                listener.enterNodetype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodetype" ):
                listener.exitNodetype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodetype" ):
                return visitor.visitNodetype(self)
            else:
                return visitor.visitChildren(self)




    def nodetype(self):

        localctx = AttributedGraphGrammarParser.NodetypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_nodetype)
        try:
            self.state = 189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 172
                self.match(AttributedGraphGrammarParser.T__3)
                self.state = 173
                self.match(AttributedGraphGrammarParser.T__1)
                self.state = 174
                self.nodetypename()
                self.state = 175
                self.startnodetype()
                self.state = 179
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
                while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1+1:
                        self.state = 176
                        self.nodetypeattribute() 
                    self.state = 181
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

                self.state = 182
                self.endnodetype()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 184
                self.match(AttributedGraphGrammarParser.T__3)
                self.state = 185
                self.match(AttributedGraphGrammarParser.T__1)
                self.state = 186
                self.nodetypename()
                self.state = 187
                self.semicolon()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodetypenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(AttributedGraphGrammarParser.ID, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodetypename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodetypename" ):
                listener.enterNodetypename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodetypename" ):
                listener.exitNodetypename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodetypename" ):
                return visitor.visitNodetypename(self)
            else:
                return visitor.visitChildren(self)




    def nodetypename(self):

        localctx = AttributedGraphGrammarParser.NodetypenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_nodetypename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self.match(AttributedGraphGrammarParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartnodetypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.LEFTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_startnodetype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartnodetype" ):
                listener.enterStartnodetype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartnodetype" ):
                listener.exitStartnodetype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartnodetype" ):
                return visitor.visitStartnodetype(self)
            else:
                return visitor.visitChildren(self)




    def startnodetype(self):

        localctx = AttributedGraphGrammarParser.StartnodetypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_startnodetype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(AttributedGraphGrammarParser.LEFTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndnodetypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.RIGHTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_endnodetype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndnodetype" ):
                listener.enterEndnodetype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndnodetype" ):
                listener.exitEndnodetype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndnodetype" ):
                return visitor.visitEndnodetype(self)
            else:
                return visitor.visitChildren(self)




    def endnodetype(self):

        localctx = AttributedGraphGrammarParser.EndnodetypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_endnodetype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(AttributedGraphGrammarParser.RIGHTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodetypeattributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodetypeattributename(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.NodetypeattributenameContext,0)


        def nodetypeattributetype(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.NodetypeattributetypeContext,0)


        def semicolon(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.SemicolonContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodetypeattribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodetypeattribute" ):
                listener.enterNodetypeattribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodetypeattribute" ):
                listener.exitNodetypeattribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodetypeattribute" ):
                return visitor.visitNodetypeattribute(self)
            else:
                return visitor.visitChildren(self)




    def nodetypeattribute(self):

        localctx = AttributedGraphGrammarParser.NodetypeattributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_nodetypeattribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(AttributedGraphGrammarParser.T__4)
            self.state = 198
            self.match(AttributedGraphGrammarParser.T__1)
            self.state = 199
            self.nodetypeattributename()
            self.state = 200
            self.nodetypeattributetype()
            self.state = 201
            self.semicolon()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodetypeattributenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodetypeattributename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodetypeattributename" ):
                listener.enterNodetypeattributename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodetypeattributename" ):
                listener.exitNodetypeattributename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodetypeattributename" ):
                return visitor.visitNodetypeattributename(self)
            else:
                return visitor.visitChildren(self)




    def nodetypeattributename(self):

        localctx = AttributedGraphGrammarParser.NodetypeattributenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_nodetypeattributename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodetypeattributetypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodetypeattributetype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodetypeattributetype" ):
                listener.enterNodetypeattributetype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodetypeattributetype" ):
                listener.exitNodetypeattributetype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodetypeattributetype" ):
                return visitor.visitNodetypeattributetype(self)
            else:
                return visitor.visitChildren(self)




    def nodetypeattributetype(self):

        localctx = AttributedGraphGrammarParser.NodetypeattributetypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_nodetypeattributetype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HostgraphnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(AttributedGraphGrammarParser.ID, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_hostgraphname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHostgraphname" ):
                listener.enterHostgraphname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHostgraphname" ):
                listener.exitHostgraphname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHostgraphname" ):
                return visitor.visitHostgraphname(self)
            else:
                return visitor.visitChildren(self)




    def hostgraphname(self):

        localctx = AttributedGraphGrammarParser.HostgraphnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_hostgraphname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            self.match(AttributedGraphGrammarParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StarthostgraphContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.LEFTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_starthostgraph

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStarthostgraph" ):
                listener.enterStarthostgraph(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStarthostgraph" ):
                listener.exitStarthostgraph(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStarthostgraph" ):
                return visitor.visitStarthostgraph(self)
            else:
                return visitor.visitChildren(self)




    def starthostgraph(self):

        localctx = AttributedGraphGrammarParser.StarthostgraphContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_starthostgraph)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(AttributedGraphGrammarParser.LEFTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndhostgraphContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.RIGHTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_endhostgraph

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndhostgraph" ):
                listener.enterEndhostgraph(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndhostgraph" ):
                listener.exitEndhostgraph(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndhostgraph" ):
                return visitor.visitEndhostgraph(self)
            else:
                return visitor.visitChildren(self)




    def endhostgraph(self):

        localctx = AttributedGraphGrammarParser.EndhostgraphContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_endhostgraph)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(AttributedGraphGrammarParser.RIGHTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rule_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rulename(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulenameContext,0)


        def startrule(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.StartruleContext,0)


        def rulelhs(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulelhsContext,0)


        def rulerhs(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulerhsContext,0)


        def endrule(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EndruleContext,0)


        def ruleparameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.RuleparameterContext)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.RuleparameterContext,i)


        def rulenac(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.RulenacContext)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.RulenacContext,i)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rule_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRule_" ):
                listener.enterRule_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRule_" ):
                listener.exitRule_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRule_" ):
                return visitor.visitRule_(self)
            else:
                return visitor.visitChildren(self)




    def rule_(self):

        localctx = AttributedGraphGrammarParser.Rule_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_rule_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(AttributedGraphGrammarParser.T__5)
            self.state = 214
            self.match(AttributedGraphGrammarParser.T__1)
            self.state = 215
            self.rulename()
            self.state = 216
            self.startrule()
            self.state = 220
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 217
                    self.ruleparameter() 
                self.state = 222
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

            self.state = 223
            self.rulelhs()
            self.state = 224
            self.rulerhs()
            self.state = 228
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 225
                    self.rulenac() 
                self.state = 230
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

            self.state = 231
            self.endrule()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulename" ):
                listener.enterRulename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulename" ):
                listener.exitRulename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulename" ):
                return visitor.visitRulename(self)
            else:
                return visitor.visitChildren(self)




    def rulename(self):

        localctx = AttributedGraphGrammarParser.RulenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_rulename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.LEFTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_startrule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartrule" ):
                listener.enterStartrule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartrule" ):
                listener.exitStartrule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartrule" ):
                return visitor.visitStartrule(self)
            else:
                return visitor.visitChildren(self)




    def startrule(self):

        localctx = AttributedGraphGrammarParser.StartruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_startrule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            self.match(AttributedGraphGrammarParser.LEFTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.RIGHTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_endrule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndrule" ):
                listener.enterEndrule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndrule" ):
                listener.exitEndrule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndrule" ):
                return visitor.visitEndrule(self)
            else:
                return visitor.visitChildren(self)




    def endrule(self):

        localctx = AttributedGraphGrammarParser.EndruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_endrule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 237
            self.match(AttributedGraphGrammarParser.RIGHTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleparameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleparametername(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RuleparameternameContext,0)


        def ruleparametertype(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RuleparametertypeContext,0)


        def semicolon(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.SemicolonContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_ruleparameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleparameter" ):
                listener.enterRuleparameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleparameter" ):
                listener.exitRuleparameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRuleparameter" ):
                return visitor.visitRuleparameter(self)
            else:
                return visitor.visitChildren(self)




    def ruleparameter(self):

        localctx = AttributedGraphGrammarParser.RuleparameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_ruleparameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self.match(AttributedGraphGrammarParser.T__6)
            self.state = 240
            self.match(AttributedGraphGrammarParser.T__1)
            self.state = 241
            self.ruleparametername()
            self.state = 242
            self.ruleparametertype()
            self.state = 243
            self.semicolon()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleparameternameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_ruleparametername

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleparametername" ):
                listener.enterRuleparametername(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleparametername" ):
                listener.exitRuleparametername(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRuleparametername" ):
                return visitor.visitRuleparametername(self)
            else:
                return visitor.visitChildren(self)




    def ruleparametername(self):

        localctx = AttributedGraphGrammarParser.RuleparameternameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_ruleparametername)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleparametertypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_ruleparametertype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleparametertype" ):
                listener.enterRuleparametertype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleparametertype" ):
                listener.exitRuleparametertype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRuleparametertype" ):
                return visitor.visitRuleparametertype(self)
            else:
                return visitor.visitChildren(self)




    def ruleparametertype(self):

        localctx = AttributedGraphGrammarParser.RuleparametertypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_ruleparametertype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulelhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def startrulelhs(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.StartrulelhsContext,0)


        def graph(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.GraphContext,0)


        def endrulelhs(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EndrulelhsContext,0)


        def rulelhsname(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulelhsnameContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulelhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulelhs" ):
                listener.enterRulelhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulelhs" ):
                listener.exitRulelhs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulelhs" ):
                return visitor.visitRulelhs(self)
            else:
                return visitor.visitChildren(self)




    def rulelhs(self):

        localctx = AttributedGraphGrammarParser.RulelhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_rulelhs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.match(AttributedGraphGrammarParser.T__7)
            self.state = 252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AttributedGraphGrammarParser.T__1:
                self.state = 250
                self.match(AttributedGraphGrammarParser.T__1)
                self.state = 251
                self.rulelhsname()


            self.state = 254
            self.startrulelhs()
            self.state = 255
            self.graph()
            self.state = 256
            self.endrulelhs()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulelhsnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulelhsname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulelhsname" ):
                listener.enterRulelhsname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulelhsname" ):
                listener.exitRulelhsname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulelhsname" ):
                return visitor.visitRulelhsname(self)
            else:
                return visitor.visitChildren(self)




    def rulelhsname(self):

        localctx = AttributedGraphGrammarParser.RulelhsnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_rulelhsname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartrulelhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.LEFTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_startrulelhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartrulelhs" ):
                listener.enterStartrulelhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartrulelhs" ):
                listener.exitStartrulelhs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartrulelhs" ):
                return visitor.visitStartrulelhs(self)
            else:
                return visitor.visitChildren(self)




    def startrulelhs(self):

        localctx = AttributedGraphGrammarParser.StartrulelhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_startrulelhs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.match(AttributedGraphGrammarParser.LEFTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndrulelhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.RIGHTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_endrulelhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndrulelhs" ):
                listener.enterEndrulelhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndrulelhs" ):
                listener.exitEndrulelhs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndrulelhs" ):
                return visitor.visitEndrulelhs(self)
            else:
                return visitor.visitChildren(self)




    def endrulelhs(self):

        localctx = AttributedGraphGrammarParser.EndrulelhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_endrulelhs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(AttributedGraphGrammarParser.RIGHTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulerhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def startrulerhs(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.StartrulerhsContext,0)


        def graph(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.GraphContext,0)


        def endrulerhs(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EndrulerhsContext,0)


        def rulerhsname(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulerhsnameContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulerhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulerhs" ):
                listener.enterRulerhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulerhs" ):
                listener.exitRulerhs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulerhs" ):
                return visitor.visitRulerhs(self)
            else:
                return visitor.visitChildren(self)




    def rulerhs(self):

        localctx = AttributedGraphGrammarParser.RulerhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_rulerhs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(AttributedGraphGrammarParser.T__8)
            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AttributedGraphGrammarParser.T__1:
                self.state = 265
                self.match(AttributedGraphGrammarParser.T__1)
                self.state = 266
                self.rulerhsname()


            self.state = 269
            self.startrulerhs()
            self.state = 270
            self.graph()
            self.state = 271
            self.endrulerhs()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulerhsnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulerhsname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulerhsname" ):
                listener.enterRulerhsname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulerhsname" ):
                listener.exitRulerhsname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulerhsname" ):
                return visitor.visitRulerhsname(self)
            else:
                return visitor.visitChildren(self)




    def rulerhsname(self):

        localctx = AttributedGraphGrammarParser.RulerhsnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_rulerhsname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 273
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartrulerhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.LEFTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_startrulerhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartrulerhs" ):
                listener.enterStartrulerhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartrulerhs" ):
                listener.exitStartrulerhs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartrulerhs" ):
                return visitor.visitStartrulerhs(self)
            else:
                return visitor.visitChildren(self)




    def startrulerhs(self):

        localctx = AttributedGraphGrammarParser.StartrulerhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_startrulerhs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self.match(AttributedGraphGrammarParser.LEFTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndrulerhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.RIGHTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_endrulerhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndrulerhs" ):
                listener.enterEndrulerhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndrulerhs" ):
                listener.exitEndrulerhs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndrulerhs" ):
                return visitor.visitEndrulerhs(self)
            else:
                return visitor.visitChildren(self)




    def endrulerhs(self):

        localctx = AttributedGraphGrammarParser.EndrulerhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_endrulerhs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self.match(AttributedGraphGrammarParser.RIGHTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulenacContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rulenacname(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulenacnameContext,0)


        def startrulenac(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.StartrulenacContext,0)


        def graph(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.GraphContext,0)


        def endrulenac(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EndrulenacContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulenac

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulenac" ):
                listener.enterRulenac(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulenac" ):
                listener.exitRulenac(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulenac" ):
                return visitor.visitRulenac(self)
            else:
                return visitor.visitChildren(self)




    def rulenac(self):

        localctx = AttributedGraphGrammarParser.RulenacContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_rulenac)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 279
            self.match(AttributedGraphGrammarParser.T__9)
            self.state = 280
            self.match(AttributedGraphGrammarParser.T__1)
            self.state = 281
            self.rulenacname()
            self.state = 282
            self.startrulenac()
            self.state = 283
            self.graph()
            self.state = 284
            self.endrulenac()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulenacnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulenacname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulenacname" ):
                listener.enterRulenacname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulenacname" ):
                listener.exitRulenacname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulenacname" ):
                return visitor.visitRulenacname(self)
            else:
                return visitor.visitChildren(self)




    def rulenacname(self):

        localctx = AttributedGraphGrammarParser.RulenacnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_rulenacname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartrulenacContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.LEFTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_startrulenac

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartrulenac" ):
                listener.enterStartrulenac(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartrulenac" ):
                listener.exitStartrulenac(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartrulenac" ):
                return visitor.visitStartrulenac(self)
            else:
                return visitor.visitChildren(self)




    def startrulenac(self):

        localctx = AttributedGraphGrammarParser.StartrulenacContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_startrulenac)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.match(AttributedGraphGrammarParser.LEFTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndrulenacContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.RIGHTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_endrulenac

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndrulenac" ):
                listener.enterEndrulenac(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndrulenac" ):
                listener.exitEndrulenac(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndrulenac" ):
                return visitor.visitEndrulenac(self)
            else:
                return visitor.visitChildren(self)




    def endrulenac(self):

        localctx = AttributedGraphGrammarParser.EndrulenacContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_endrulenac)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.match(AttributedGraphGrammarParser.RIGHTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GraphContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def graphstructures(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.GraphstructuresContext)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.GraphstructuresContext,i)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_graph

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGraph" ):
                listener.enterGraph(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGraph" ):
                listener.exitGraph(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGraph" ):
                return visitor.visitGraph(self)
            else:
                return visitor.visitChildren(self)




    def graph(self):

        localctx = AttributedGraphGrammarParser.GraphContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_graph)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AttributedGraphGrammarParser.T__10 or _la==AttributedGraphGrammarParser.STRING:
                self.state = 292
                self.graphstructures()
                self.state = 297
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GraphstructuresContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def addnode(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.AddnodeContext,0)


        def addedge(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.AddedgeContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_graphstructures

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGraphstructures" ):
                listener.enterGraphstructures(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGraphstructures" ):
                listener.exitGraphstructures(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGraphstructures" ):
                return visitor.visitGraphstructures(self)
            else:
                return visitor.visitChildren(self)




    def graphstructures(self):

        localctx = AttributedGraphGrammarParser.GraphstructuresContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_graphstructures)
        try:
            self.state = 300
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AttributedGraphGrammarParser.T__10]:
                self.enterOuterAlt(localctx, 1)
                self.state = 298
                self.addnode()
                pass
            elif token in [AttributedGraphGrammarParser.STRING]:
                self.enterOuterAlt(localctx, 2)
                self.state = 299
                self.addedge()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddnodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodename(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.NodenameContext,0)


        def nodeType(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.NodeTypeContext,0)


        def nodeTypeValue(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.NodeTypeValueContext,0)


        def semicolon(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.SemicolonContext,0)


        def nodeattribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.NodeattributeContext)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.NodeattributeContext,i)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_addnode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddnode" ):
                listener.enterAddnode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddnode" ):
                listener.exitAddnode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddnode" ):
                return visitor.visitAddnode(self)
            else:
                return visitor.visitChildren(self)




    def addnode(self):

        localctx = AttributedGraphGrammarParser.AddnodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_addnode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.match(AttributedGraphGrammarParser.T__10)
            self.state = 303
            self.nodename()
            self.state = 304
            self.match(AttributedGraphGrammarParser.T__11)
            self.state = 305
            self.nodeType()
            self.state = 306
            self.match(AttributedGraphGrammarParser.T__12)
            self.state = 307
            self.nodeTypeValue()
            self.state = 312
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 308
                    self.match(AttributedGraphGrammarParser.T__11)
                    self.state = 309
                    self.nodeattribute() 
                self.state = 314
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

            self.state = 315
            self.semicolon()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddedgeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def edgesource(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EdgesourceContext,0)


        def edgetarget(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EdgetargetContext,0)


        def semicolon(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.SemicolonContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_addedge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddedge" ):
                listener.enterAddedge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddedge" ):
                listener.exitAddedge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddedge" ):
                return visitor.visitAddedge(self)
            else:
                return visitor.visitChildren(self)




    def addedge(self):

        localctx = AttributedGraphGrammarParser.AddedgeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_addedge)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 317
            self.edgesource()
            self.state = 318
            self.match(AttributedGraphGrammarParser.T__13)
            self.state = 319
            self.edgetarget()
            self.state = 320
            self.semicolon()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodename" ):
                listener.enterNodename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodename" ):
                listener.exitNodename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodename" ):
                return visitor.visitNodename(self)
            else:
                return visitor.visitChildren(self)




    def nodename(self):

        localctx = AttributedGraphGrammarParser.NodenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_nodename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodeTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeType" ):
                listener.enterNodeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeType" ):
                listener.exitNodeType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodeType" ):
                return visitor.visitNodeType(self)
            else:
                return visitor.visitChildren(self)




    def nodeType(self):

        localctx = AttributedGraphGrammarParser.NodeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_nodeType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(AttributedGraphGrammarParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodeTypeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodeTypeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeTypeValue" ):
                listener.enterNodeTypeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeTypeValue" ):
                listener.exitNodeTypeValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodeTypeValue" ):
                return visitor.visitNodeTypeValue(self)
            else:
                return visitor.visitChildren(self)




    def nodeTypeValue(self):

        localctx = AttributedGraphGrammarParser.NodeTypeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_nodeTypeValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 326
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodeattributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodeattributename(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.NodeattributenameContext,0)


        def nodeattributevalue(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.NodeattributevalueContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodeattribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeattribute" ):
                listener.enterNodeattribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeattribute" ):
                listener.exitNodeattribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodeattribute" ):
                return visitor.visitNodeattribute(self)
            else:
                return visitor.visitChildren(self)




    def nodeattribute(self):

        localctx = AttributedGraphGrammarParser.NodeattributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_nodeattribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.nodeattributename()
            self.state = 329
            self.match(AttributedGraphGrammarParser.T__12)
            self.state = 330
            self.nodeattributevalue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodeattributenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(AttributedGraphGrammarParser.ID, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodeattributename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeattributename" ):
                listener.enterNodeattributename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeattributename" ):
                listener.exitNodeattributename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodeattributename" ):
                return visitor.visitNodeattributename(self)
            else:
                return visitor.visitChildren(self)




    def nodeattributename(self):

        localctx = AttributedGraphGrammarParser.NodeattributenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_nodeattributename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            self.match(AttributedGraphGrammarParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NodeattributevalueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def INT(self):
            return self.getToken(AttributedGraphGrammarParser.INT, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_nodeattributevalue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeattributevalue" ):
                listener.enterNodeattributevalue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeattributevalue" ):
                listener.exitNodeattributevalue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodeattributevalue" ):
                return visitor.visitNodeattributevalue(self)
            else:
                return visitor.visitChildren(self)




    def nodeattributevalue(self):

        localctx = AttributedGraphGrammarParser.NodeattributevalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_nodeattributevalue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            _la = self._input.LA(1)
            if not(_la==AttributedGraphGrammarParser.INT or _la==AttributedGraphGrammarParser.STRING):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EdgesourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_edgesource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEdgesource" ):
                listener.enterEdgesource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEdgesource" ):
                listener.exitEdgesource(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEdgesource" ):
                return visitor.visitEdgesource(self)
            else:
                return visitor.visitChildren(self)




    def edgesource(self):

        localctx = AttributedGraphGrammarParser.EdgesourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_edgesource)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EdgetargetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_edgetarget

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEdgetarget" ):
                listener.enterEdgetarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEdgetarget" ):
                listener.exitEdgetarget(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEdgetarget" ):
                return visitor.visitEdgetarget(self)
            else:
                return visitor.visitChildren(self)




    def edgetarget(self):

        localctx = AttributedGraphGrammarParser.EdgetargetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_edgetarget)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulesequencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rulesequence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.RulesequenceContext)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.RulesequenceContext,i)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulesequences

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulesequences" ):
                listener.enterRulesequences(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulesequences" ):
                listener.exitRulesequences(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulesequences" ):
                return visitor.visitRulesequences(self)
            else:
                return visitor.visitChildren(self)




    def rulesequences(self):

        localctx = AttributedGraphGrammarParser.RulesequencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_rulesequences)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 340
                self.rulesequence()
                self.state = 343 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==AttributedGraphGrammarParser.T__14):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulesequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rulesequencename(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulesequencenameContext,0)


        def startrulesequence(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.StartrulesequenceContext,0)


        def subsequences(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.SubsequencesContext,0)


        def endrulesequence(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EndrulesequenceContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulesequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulesequence" ):
                listener.enterRulesequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulesequence" ):
                listener.exitRulesequence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulesequence" ):
                return visitor.visitRulesequence(self)
            else:
                return visitor.visitChildren(self)




    def rulesequence(self):

        localctx = AttributedGraphGrammarParser.RulesequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_rulesequence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 345
            self.match(AttributedGraphGrammarParser.T__14)
            self.state = 346
            self.match(AttributedGraphGrammarParser.T__1)
            self.state = 347
            self.rulesequencename()
            self.state = 348
            self.startrulesequence()
            self.state = 349
            self.subsequences()
            self.state = 350
            self.endrulesequence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulesequencenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulesequencename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulesequencename" ):
                listener.enterRulesequencename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulesequencename" ):
                listener.exitRulesequencename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulesequencename" ):
                return visitor.visitRulesequencename(self)
            else:
                return visitor.visitChildren(self)




    def rulesequencename(self):

        localctx = AttributedGraphGrammarParser.RulesequencenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_rulesequencename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 352
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartrulesequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.LEFTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_startrulesequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartrulesequence" ):
                listener.enterStartrulesequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartrulesequence" ):
                listener.exitStartrulesequence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartrulesequence" ):
                return visitor.visitStartrulesequence(self)
            else:
                return visitor.visitChildren(self)




    def startrulesequence(self):

        localctx = AttributedGraphGrammarParser.StartrulesequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_startrulesequence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 354
            self.match(AttributedGraphGrammarParser.LEFTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubsequencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subsequence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.SubsequenceContext)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.SubsequenceContext,i)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_subsequences

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubsequences" ):
                listener.enterSubsequences(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubsequences" ):
                listener.exitSubsequences(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubsequences" ):
                return visitor.visitSubsequences(self)
            else:
                return visitor.visitChildren(self)




    def subsequences(self):

        localctx = AttributedGraphGrammarParser.SubsequencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_subsequences)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AttributedGraphGrammarParser.T__15:
                self.state = 356
                self.subsequence()
                self.state = 361
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndrulesequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.RIGHTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_endrulesequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndrulesequence" ):
                listener.enterEndrulesequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndrulesequence" ):
                listener.exitEndrulesequence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndrulesequence" ):
                return visitor.visitEndrulesequence(self)
            else:
                return visitor.visitChildren(self)




    def endrulesequence(self):

        localctx = AttributedGraphGrammarParser.EndrulesequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_endrulesequence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 362
            self.match(AttributedGraphGrammarParser.RIGHTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubsequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subsequenceiternationcount(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.SubsequenceiternationcountContext,0)


        def startsubsequence(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.StartsubsequenceContext,0)


        def endsubsequence(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.EndsubsequenceContext,0)


        def rulesequnececount(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AttributedGraphGrammarParser.RulesequnececountContext)
            else:
                return self.getTypedRuleContext(AttributedGraphGrammarParser.RulesequnececountContext,i)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_subsequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubsequence" ):
                listener.enterSubsequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubsequence" ):
                listener.exitSubsequence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubsequence" ):
                return visitor.visitSubsequence(self)
            else:
                return visitor.visitChildren(self)




    def subsequence(self):

        localctx = AttributedGraphGrammarParser.SubsequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_subsequence)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 364
            self.match(AttributedGraphGrammarParser.T__15)
            self.state = 365
            self.match(AttributedGraphGrammarParser.T__1)
            self.state = 366
            self.subsequenceiternationcount()
            self.state = 367
            self.startsubsequence()
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==AttributedGraphGrammarParser.STRING:
                self.state = 368
                self.rulesequnececount()
                self.state = 373
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 374
            self.endsubsequence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubsequenceiternationcountContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(AttributedGraphGrammarParser.INT, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_subsequenceiternationcount

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubsequenceiternationcount" ):
                listener.enterSubsequenceiternationcount(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubsequenceiternationcount" ):
                listener.exitSubsequenceiternationcount(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubsequenceiternationcount" ):
                return visitor.visitSubsequenceiternationcount(self)
            else:
                return visitor.visitChildren(self)




    def subsequenceiternationcount(self):

        localctx = AttributedGraphGrammarParser.SubsequenceiternationcountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_subsequenceiternationcount)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(AttributedGraphGrammarParser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartsubsequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.LEFTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_startsubsequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartsubsequence" ):
                listener.enterStartsubsequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartsubsequence" ):
                listener.exitStartsubsequence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartsubsequence" ):
                return visitor.visitStartsubsequence(self)
            else:
                return visitor.visitChildren(self)




    def startsubsequence(self):

        localctx = AttributedGraphGrammarParser.StartsubsequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_startsubsequence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 378
            self.match(AttributedGraphGrammarParser.LEFTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulesequnececountContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rulesequencerulename(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulesequencerulenameContext,0)


        def rulecount(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.RulecountContext,0)


        def semicolon(self):
            return self.getTypedRuleContext(AttributedGraphGrammarParser.SemicolonContext,0)


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulesequnececount

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulesequnececount" ):
                listener.enterRulesequnececount(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulesequnececount" ):
                listener.exitRulesequnececount(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulesequnececount" ):
                return visitor.visitRulesequnececount(self)
            else:
                return visitor.visitChildren(self)




    def rulesequnececount(self):

        localctx = AttributedGraphGrammarParser.RulesequnececountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_rulesequnececount)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 380
            self.rulesequencerulename()
            self.state = 381
            self.match(AttributedGraphGrammarParser.T__1)
            self.state = 382
            self.rulecount()
            self.state = 383
            self.semicolon()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulesequencerulenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(AttributedGraphGrammarParser.STRING, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulesequencerulename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulesequencerulename" ):
                listener.enterRulesequencerulename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulesequencerulename" ):
                listener.exitRulesequencerulename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulesequencerulename" ):
                return visitor.visitRulesequencerulename(self)
            else:
                return visitor.visitChildren(self)




    def rulesequencerulename(self):

        localctx = AttributedGraphGrammarParser.RulesequencerulenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_rulesequencerulename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            self.match(AttributedGraphGrammarParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulecountContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(AttributedGraphGrammarParser.INT, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_rulecount

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulecount" ):
                listener.enterRulecount(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulecount" ):
                listener.exitRulecount(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRulecount" ):
                return visitor.visitRulecount(self)
            else:
                return visitor.visitChildren(self)




    def rulecount(self):

        localctx = AttributedGraphGrammarParser.RulecountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_rulecount)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.match(AttributedGraphGrammarParser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndsubsequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHTPARAN(self):
            return self.getToken(AttributedGraphGrammarParser.RIGHTPARAN, 0)

        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_endsubsequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndsubsequence" ):
                listener.enterEndsubsequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndsubsequence" ):
                listener.exitEndsubsequence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndsubsequence" ):
                return visitor.visitEndsubsequence(self)
            else:
                return visitor.visitChildren(self)




    def endsubsequence(self):

        localctx = AttributedGraphGrammarParser.EndsubsequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_endsubsequence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 389
            self.match(AttributedGraphGrammarParser.RIGHTPARAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SemicolonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AttributedGraphGrammarParser.RULE_semicolon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSemicolon" ):
                listener.enterSemicolon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSemicolon" ):
                listener.exitSemicolon(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSemicolon" ):
                return visitor.visitSemicolon(self)
            else:
                return visitor.visitChildren(self)




    def semicolon(self):

        localctx = AttributedGraphGrammarParser.SemicolonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_semicolon)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 391
            self.match(AttributedGraphGrammarParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





